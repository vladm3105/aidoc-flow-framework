# SPEC-01: [EXTERNAL_API] Client Specification
# This is a template example showing YAML specification format
# Replace all [PLACEHOLDERS] with your project-specific values

component_name: "[COMPONENT_NAME - e.g., payment_gateway_client, weather_api_client]"
component_type: "service"  # service | agent | library | infrastructure | ml_model
version: "1.0.0"
status: "example"  # planning | development | testing | production

# === TRACEABILITY ===
requirements:
  - "REQ-01"  # [EXTERNAL_API] Integration
  - "REQ-02"  # Data Validation
  - "REQ-XXX"  # [Additional requirements]

adrs:
  - "ADR-XXX"  # [External Integration Architecture]
  - "ADR-YYY"  # [API Client Patterns]

bdd_scenarios:
  - "[FEATURE_FILE.feature - e.g., api_integration.feature]"
  - "[FEATURE_FILE.feature - e.g., error_handling.feature]"

business_logic_source:
  - "[DOCUMENT_PATH - e.g., product_strategy/external_integrations.md::section 3.2]"
  - "[DOCUMENT_PATH - e.g., business_requirements/api_strategy.md::section 2.1]"

# === COMPONENT METADATA ===
metadata:
  owner: "[TEAM_NAME - e.g., Integration Team, Platform Team]"
  repository: "[REPO_URL - e.g., github.com/org/repo]"
  documentation: "[DOC_URL - e.g., docs.example.com/api-client]"
  support_channel: "[CHANNEL - e.g., #team-integrations slack channel]"

# === DEPENDENCIES ===
dependencies:
  external:
    - name: "[LIBRARY_NAME - e.g., requests, axios, http client lib]"
      version: "[VERSION - e.g., ^2.28.0]"
      purpose: "HTTP client for API calls"

    - name: "[LIBRARY_NAME - e.g., pydantic, joi, json-schema]"
      version: "[VERSION]"
      purpose: "Request/response validation"

    - name: "[LIBRARY_NAME - e.g., tenacity, retry, resilience4j]"
      version: "[VERSION]"
      purpose: "Retry logic with exponential backoff"

  internal:
    - component: "[COMPONENT - e.g., logging_service]"
      interface: "[INTERFACE - e.g., CTR-XXX_logging_api.yaml]"
      purpose: "Structured logging and correlation tracking"

    - component: "[COMPONENT - e.g., metrics_service]"
      interface: "[INTERFACE - e.g., CTR-YYY_metrics_api.yaml]"
      purpose: "Performance metrics and monitoring"

    - component: "[COMPONENT - e.g., config_service]"
      interface: "[INTERFACE - e.g., CTR-ZZZ_config_api.yaml]"
      purpose: "Dynamic configuration management"

# === CONFIGURATION ===
configuration:
  environment_variables:
    - name: "[API_BASE_URL - e.g., PAYMENT_API_URL]"
      type: "string"
      required: true
      default: "[DEFAULT - e.g., https://api.example.com/v1]"
      description: "Base URL for [EXTERNAL_API]"

    - name: "[API_KEY_REF - e.g., PAYMENT_API_KEY]"
      type: "Secret"
      required: true
      Secret_path: "[PATH - e.g., ${vault:api/credentials#api_key}]"
      description: "Authentication credential"

    - name: "[TIMEOUT_MS - e.g., API_TIMEOUT_MS]"
      type: "integer"
      required: false
      default: 5000
      validation:
        minimum: 1000
        maximum: 30000
      description: "Request timeout in milliseconds"

    - name: "[MAX_RETRIES - e.g., API_MAX_RETRIES]"
      type: "integer"
      required: false
      default: 3
      validation:
        minimum: 0
        maximum: 10
      description: "Maximum retry attempts for failed requests"

  config_file:
    path: "[PATH - e.g., config/api_client.yaml]"
    format: "yaml"
    schema:
      rate_limiting:
        requests_per_minute: "[LIMIT - e.g., 100]"
        burst_size: "[BURST - e.g., 20]"

      circuit_breaker:
        failure_threshold: "[THRESHOLD - e.g., 5]"
        timeout_seconds: "[TIMEOUT - e.g., 30]"
        half_open_requests: "[COUNT - e.g., 3]"

      retry_policy:
        initial_delay_ms: 1000
        max_delay_ms: 32000
        multiplier: 2.0
        retryable_status_codes: [408, 429, 500, 502, 503, 504]

# === API SPECIFICATION ===
api:
  base_path: "/[PATH - e.g., api/v1]"
  authentication:
    type: "[TYPE - e.g., api_key, oauth2, bearer_token, mutual_tls]"
    location: "[LOCATION - e.g., header, query_param]"
    header_name: "[HEADER - e.g., X-API-Key, Authorization]"

  endpoints:
    - name: "[ENDPOINT_NAME - e.g., create_transaction]"
      path: "/[PATH - e.g., transactions]"
      method: "POST"
      description: "[DESCRIPTION - e.g., Create new transaction]"

      request:
        content_type: "application/json"
        schema:
          type: "object"
          required: ["[FIELD_1]", "[FIELD_2]"]
          properties:
            "[FIELD_1]":
              type: "[TYPE - e.g., string, integer, object]"
              description: "[DESCRIPTION]"
              validation: "[RULES - e.g., min_length: 1, max_length: 255]"
            "[FIELD_2]":
              type: "[TYPE]"
              description: "[DESCRIPTION]"

      response:
        success:
          status_code: 201
          content_type: "application/json"
          schema:
            type: "object"
            properties:
              id: { type: "string", format: "uuid" }
              status: { type: "string", enum: ["pending", "completed", "failed"] }
              created_at: { type: "string", format: "date-time" }

        errors:
          - status_code: 400
            description: "Invalid request parameters"
            schema:
              error_code: "INVALID_REQUEST"
              error_message: "string"

          - status_code: 401
            description: "Authentication failed"
            schema:
              error_code: "UNAUTHORIZED"

          - status_code: 429
            description: "Rate limit exceeded"
            headers:
              Retry-After: "integer (seconds)"

    - name: "[ENDPOINT_NAME - e.g., get_transaction_status]"
      path: "/[PATH]/{transaction_id}"
      method: "GET"
      description: "[DESCRIPTION]"

      parameters:
        - name: "transaction_id"
          in: "path"
          required: true
          type: "string"
          format: "uuid"

      response:
        success:
          status_code: 200
          schema:
            type: "object"
            properties:
              id: { type: "string" }
              status: { type: "string" }
              updated_at: { type: "string", format: "date-time" }

# === IMPLEMENTATION ===
implementation:
  language: "[LANGUAGE - e.g., Python, TypeScript, Java, Go]"
  framework: "[FRAMEWORK - e.g., FastAPI, Express, Spring Boot]"

  classes:
    - name: "[CLASS_NAME - e.g., ExternalAPIClient]"
      type: "class"
      responsibility: "Main client interface for [EXTERNAL_API]"

      methods:
        - name: "[METHOD_NAME - e.g., create_transaction]"
          visibility: "public"
          parameters:
            - name: "[PARAM - e.g., transaction_data]"
              type: "[TYPE - e.g., TransactionRequest]"
              validation: "Pydantic model validation"

          returns:
            type: "[TYPE - e.g., TransactionResponse]"
            description: "Transaction details with ID and status"

          raises:
            - exception: "[EXCEPTION - e.g., APIAuthenticationError]"
              condition: "Invalid or expired credentials"
            - exception: "[EXCEPTION - e.g., APIRateLimitError]"
              condition: "Rate limit exceeded"
            - exception: "[EXCEPTION - e.g., APIServerError]"
              condition: "Upstream server error (5xx)"

          business_logic:
            - "Validate request parameters using Pydantic"
            - "Add authentication headers"
            - "Send POST request to [EXTERNAL_API]"
            - "Parse and validate response schema"
            - "Log transaction ID for correlation"
            - "Return typed response object"

        - name: "[METHOD_NAME - e.g., get_status]"
          visibility: "public"
          parameters:
            - name: "transaction_id"
              type: "str"
          returns:
            type: "[TYPE - e.g., TransactionStatus]"
          business_logic:
            - "Send GET request with transaction_id"
            - "Handle 404 as TransactionNotFound"
            - "Return status object"

    - name: "[CLASS_NAME - e.g., RetryHandler]"
      type: "class"
      responsibility: "Implements retry logic with exponential backoff"

      methods:
        - name: "execute_with_retry"
          parameters:
            - name: "operation"
              type: "Callable"
            - name: "max_retries"
              type: "int"
          returns:
            type: "Any"
          business_logic:
            - "Execute operation"
            - "On failure, check if retryable (status code in config)"
            - "Wait with exponential backoff: delay = base_delay * (multiplier ^ attempt)"
            - "Retry up to max_retries times"
            - "Raise exception if all retries exhausted"

    - name: "[CLASS_NAME - e.g., CircuitBreaker]"
      type: "class"
      responsibility: "Prevents cascading failures using circuit breaker pattern"

      state:
        - "CLOSED: Normal operation, requests pass through"
        - "OPEN: Too many failures, requests fail fast"
        - "HALF_OPEN: Testing if service recovered"

      methods:
        - name: "call"
          business_logic:
            - "If OPEN and timeout not elapsed: raise CircuitBreakerOpenError"
            - "If OPEN and timeout elapsed: transition to HALF_OPEN, allow limited requests"
            - "If HALF_OPEN: execute request, on success transition to CLOSED, on failure return to OPEN"
            - "If CLOSED: execute request, track failures, open circuit if threshold exceeded"

# === ERROR HANDLING ===
error_handling:
  exception_hierarchy:
    - name: "[BASE_EXCEPTION - e.g., APIClientError]"
      description: "Base exception for all API client errors"

      subclasses:
        - name: "[EXCEPTION - e.g., APIAuthenticationError]"
          status_code: 401
          retryable: false
          action: "Refresh credentials and retry"

        - name: "[EXCEPTION - e.g., APIRateLimitError]"
          status_code: 429
          retryable: true
          action: "Wait for Retry-After header duration"

        - name: "[EXCEPTION - e.g., APIServerError]"
          status_code: 500-599
          retryable: true
          action: "Retry with exponential backoff"

        - name: "[EXCEPTION - e.g., APITimeoutError]"
          status_code: null
          retryable: true
          action: "Retry with increased timeout"

        - name: "[EXCEPTION - e.g., APIValidationError]"
          status_code: 400
          retryable: false
          action: "Fix request parameters"

  logging:
    - level: "INFO"
      events: ["request_sent", "response_received"]
      fields: ["correlation_id", "endpoint", "status_code", "latency_ms"]

    - level: "WARNING"
      events: ["retry_attempt", "circuit_breaker_opened"]
      fields: ["attempt_number", "error_type", "next_retry_delay_ms"]

    - level: "ERROR"
      events: ["request_failed", "all_retries_exhausted"]
      fields: ["error_message", "stack_trace", "request_body"]

# === PERFORMANCE ===
performance:
  targets:
    latency_p50_ms: "[TARGET - e.g., 200]"
    latency_p95_ms: "[TARGET - e.g., 500]"
    latency_p99_ms: "[TARGET - e.g., 1000]"
    throughput_rps: "[TARGET - e.g., 100]"

  optimization:
    - "Connection pooling: max [POOL_SIZE - e.g., 100] connections"
    - "HTTP/2 multiplexing enabled"
    - "Response caching for [CACHEABLE_ENDPOINTS]"
    - "Request batching for bulk operations"
    - "Compression: gzip/brotli for large payloads"

  monitoring:
    metrics:
      - "api_requests_total (counter)"
      - "api_request_duration_seconds (histogram)"
      - "api_errors_total (counter by error_type)"
      - "circuit_breaker_state (gauge)"
      - "rate_limit_remaining (gauge)"

# === TESTING ===
testing:
  unit_tests:
    coverage_target: 95
    frameworks: ["[FRAMEWORK - e.g., pytest, jest, junit]"]
    focus_areas:
      - "Request/response transformation"
      - "Retry logic edge cases"
      - "Circuit breaker state transitions"
      - "Error handling and exception mapping"

  integration_tests:
    coverage_target: 85
    approach: "Mock [EXTERNAL_API] using [TOOL - e.g., WireMock, nock, vcr]"
    scenarios:
      - "Successful request/response flow"
      - "Authentication failure handling"
      - "Rate limiting behavior"
      - "Network timeout simulation"
      - "Server error retry logic"

  contract_tests:
    tool: "[TOOL - e.g., Pact, Spring Cloud Contract]"
    provider: "[EXTERNAL_API]"
    consumer: "[YOUR_SERVICE]"
    verification: "Ensure API schema compliance"

  performance_tests:
    tool: "[TOOL - e.g., Locust, k6, JMeter]"
    scenarios:
      - load: "[TPS] requests/second for [DURATION] minutes"
      - stress: "Ramp up to [MAX_TPS] to find breaking point"
      - spike: "Sudden [SPIKE_TPS] burst for [DURATION]"

# === SECURITY ===
security:
  authentication:
    credential_storage: "[MECHANISM - e.g., HashiCorp Vault, AWS Secrets Manager]"
    rotation_policy: "[POLICY - e.g., Every 90 days]"
    encryption: "TLS 1.3+ for all communication"

  input_validation:
    - "Validate all request parameters using schema"
    - "Sanitize user-provided data before sending to API"
    - "Reject requests with invalid/malicious payloads"

  output_validation:
    - "Verify response schema matches expected format"
    - "Detect and reject tampered responses"
    - "Log suspicious response patterns"

  audit:
    - "Log all API calls with user context"
    - "Retention: [PERIOD - e.g., 90 days]"
    - "Immutable audit trail in [SYSTEM - e.g., Cloud Logging, Splunk]"

# === DEPLOYMENT ===
deployment:
  containerization:
    base_image: "[IMAGE - e.g., python:3.11-slim, node:18-alpine]"
    registry: "[REGISTRY - e.g., gcr.io, docker.io]"

  infrastructure:
    platform: "[PLATFORM - e.g., Kubernetes, ECS, Cloud Run]"
    scaling:
      min_instances: "[MIN - e.g., 2]"
      max_instances: "[MAX - e.g., 10]"
      cpu_target: "[TARGET - e.g., 70%]"
      memory_target: "[TARGET - e.g., 80%]"

  health_checks:
    liveness: "/health/live"
    readiness: "/health/ready"
    startup: "/health/startup"

  observability:
    logging: "[SYSTEM - e.g., Cloud Logging, ELK Stack]"
    metrics: "[SYSTEM - e.g., Prometheus, Datadog]"
    tracing: "[SYSTEM - e.g., Jaeger, Cloud Trace]"
    dashboards: "[TOOL - e.g., Grafana, Datadog]"

# === ACCEPTANCE CRITERIA (FROM BDD) ===
acceptance_criteria:
  - id: "SPEC.01.06.01"
    scenario: "Successful API call"
    given: "Valid authentication credentials"
    when: "Client makes request to [ENDPOINT]"
    then: "Response received within [TIMEOUT]ms with status 2xx"

  - id: "SPEC.01.06.02"
    scenario: "Rate limit handling"
    given: "Rate limit is reached"
    when: "Client makes additional request"
    then: "Request is queued/rejected with appropriate error"

  - id: "SPEC.01.06.03"
    scenario: "Circuit breaker activation"
    given: "[THRESHOLD] consecutive failures"
    when: "Circuit breaker opens"
    then: "Subsequent requests fail fast for [TIMEOUT] seconds"

# === MIGRATION PLAN (if applicable) ===
migration:
  from: "[OLD_SYSTEM - e.g., Legacy SOAP client]"
  to: "[NEW_SYSTEM - e.g., REST API client]"
  strategy: "[STRATEGY - e.g., Parallel run, Feature flag, Blue-green]"
  rollback_plan: "[PLAN]"

---
# Example Usage Notes:
# This is a template specification. Replace all [PLACEHOLDERS] with your actual values.
# Use this YAML as input to code generation tools (see index.md#traceability-flow).
